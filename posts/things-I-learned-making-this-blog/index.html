<!DOCTYPE html>
<html lang="en">
  <head>
    <title>A Potpourri of Things I Learned Making This Blog</title>
    <!-- Meta. -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="description" content="A summary of a few random things I learned making this blog.">

    <!-- Favicon. -->
    <link rel="icon" type="image/svg+xml" href="/images/favicon.png">

    <!-- Styling for common components. -->
    <link rel="stylesheet" href="/style/common.css">
    <!-- Conditional CSS. -->
  
    <link rel="stylesheet" href="/style/post.css">
    <link rel="stylesheet" href="/style/github.css" id="theme-link">
      
    <!-- Common scripts. -->
    <script src="/scripts/common.js" async></script>
    <!-- Conditional scripts. -->
   </head>

  <body>
    <header>
      <div id="navbar">
        <a href="/">Home</a>
        <a href="/posts/index.html">Blog</a>
        <a href="/projects.html">Projects</a>
        <a href="/about.html">About</a>
      </div>
    </header>
    <div id="content"><div class="post-content">
  <h1 class="post-title"><a href="index.html">A Potpourri of Things I Learned Making This Blog</a></h1>
  <small class="post-info">
    <div>
      <svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" width="24">
        <path d="M0 0h24v24H0z" fill="none"/>
        <path d="M17 12h-5v5h5v-5zM16 1v2H8V1H6v2H5c-1.11 0-1.99.9-1.99 2L3 19c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2h-1V1h-2zm3 18H5V8h14v11z"/>
      </svg>
      Published Mon Dec 07 2020
    </div>
    <div>
      <svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" width="24" class="schedule">
        <path d="M0 0h24v24H0z" fill="none"/>
        <path d="M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"/>
        <path d="M12.5 7H11v6l5.25 3.15.75-1.23-4.5-2.67z"/>
      </svg>
      10 min read
    </div>
  </small>
  
  <div class="toc-wrapper">
    <div class="toc">
      <h1 class="contents-title">Contents</h1>
       <a href="#implementing-dark-mode">
<h1 class="toc-entry" style="text-indent:0">
<span class="toc-numb">1 </span>Implementing dark mode</h1></a>  <a href="#css-variables">
<h2 class="toc-entry" style="text-indent:10px">
<span class="toc-numb">1.1 </span>CSS variables</h2></a>  <a href="#the-code-class-inline-code-localstorage-code-api">
<h2 class="toc-entry" style="text-indent:10px">
<span class="toc-numb">1.2 </span>The <code class="inline-code">localStorage</code> API</h2></a>  <a href="#service-workers">
<h1 class="toc-entry" style="text-indent:0">
<span class="toc-numb">2 </span>Service Workers</h1></a>  <a href="#-code-class-inline-code-async-code-and-code-class-inline-code-defer-code-attributes-for-code-class-inline-code-lt-script-gt-code-tags">
<h1 class="toc-entry" style="text-indent:0">
<span class="toc-numb">3 </span><code class="inline-code">async</code> and <code class="inline-code">defer</code> attributes for <code class="inline-code">&lt;script&gt;</code> tags</h1></a>  <a href="#document-state">
<h1 class="toc-entry" style="text-indent:0">
<span class="toc-numb">4 </span>Document state</h1></a>  <a href="#-code-class-inline-code-pointer-events-code-css-property">
<h1 class="toc-entry" style="text-indent:0">
<span class="toc-numb">5 </span><code class="inline-code">-pointer-events</code> CSS property</h1></a>  <a href="#-code-class-inline-code-min-width-code-and-code-class-inline-code-min-device-width-code-ignorance">
<h1 class="toc-entry" style="text-indent:0">
<span class="toc-numb">6 </span><code class="inline-code">min-width</code> and <code class="inline-code">min-device-width</code> ignorance</h1></a>  <a href="#text-size-adjust">
<h1 class="toc-entry" style="text-indent:0">
<span class="toc-numb">7 </span>text size adjust</h1></a>  <a href="#python-server-vs-node-server">
<h1 class="toc-entry" style="text-indent:0">
<span class="toc-numb">8 </span>python server vs node server</h1></a>  <a href="#icons-using-svgs">
<h1 class="toc-entry" style="text-indent:0">
<span class="toc-numb">9 </span>Icons using SVGs</h1></a>  <a href="#sass-to-organize-and-minify-css">
<h1 class="toc-entry" style="text-indent:0">
<span class="toc-numb">10 </span>SASS to organize and minify CSS</h1></a> 
    </div>
  </div>
   <p>While working on this blog I learned some cool stuff. I won’t go into detail explaining each thing, but simply knowing that something exists can be pretty useful. So here, in no particular order, I’ll mention the existence of some of the things I learned. If it’s something you haven’t heard of you can then consider it’s usefulness.</p>
<h1 class="post-body-header">
              <a name="implementing-dark-mode" href="#implementing-dark-mode">Implementing dark mode</a>
            </h1><p>I decided it would be cool and trendy to add dark mode to my website. I had no idea where to start, but in the end implementing a switch to toggle dark mode involved:</p>
<ul>
<li>Add some arbitrary attribute <code class="inline-code">X</code> to all DOM elements you want to change when switching themes</li>
<li>In a JS script, when the user hits the dark mode button get all elements with attribute <code class="inline-code">X</code> and label them with some <a href="https://developer.mozilla.org/en-US/docs/Learn/HTML/Howto/Use_data_attributes" title="" class="md-link">data attribute</a> (e.g. <code class="inline-code">data-theme=&quot;dark&quot;</code>).</li>
<li>Write some CSS for each light/dark theme conditionally applying a theme depending on the <code class="inline-code">data-*</code> attribute of that element.</li>
</ul>
<p>There are some other things to consider that I won’t go into detail in, such as:</p>
<ul>
<li>Changing the theme given the user chosen OS theme.</li>
<li>Listening for changes if the user changes his preferred OS theme.</li>
</ul>
<p>There is no shortage of good articles explaining how to implement dark mode.</p>
<p>Anyway, the two new things I learned were the existence of CSS variables and the <code class="inline-code">localStorage</code> API.</p>
<h2 class="post-body-header">
              <a name="css-variables" href="#css-variables">CSS variables</a>
            </h2><p>This actually isn’t mandatory but using <a href="https://www.w3schools.com/css/css3_variables.asp" title="" class="md-link">CSS variables</a> makes it a whole lot easier to implement dark mode. You simply create two themes (light and dark) where each theme will have a set of variables.</p>
<p>For example just in the case of switching the background color of the <code class="inline-code">html</code> element:</p>
<div class="code-block-wrapper"><div><pre class="code-block"><code class="language-css"><span class="hljs-selector-pseudo">:root</span> {
    --dark-<span class="hljs-attribute">background</span>: black;
    --light-<span class="hljs-attribute">background</span>: white;
}</code></pre></div></div>
<p>You can declare the variables in <code class="inline-code">:root</code> so as to add them to the global scope.</p>
<p>Then you can conditionally apply a styling depending on a <code class="inline-code">data-*</code> attribute of an element:</p>
<div class="code-block-wrapper"><div><pre class="code-block"><code class="language-css"><span class="hljs-selector-tag">html</span> {
    <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">var</span>(--light-background);
}

<span class="hljs-selector-tag">html</span><span class="hljs-selector-attr">[data-theme=<span class="hljs-string">&#x27;dark&#x27;</span>]</span> {
    <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">var</span>(--dark-background);
}</code></pre></div></div>
<h2 class="post-body-header">
              <a name="the-code-class-inline-code-localstorage-code-api" href="#the-code-class-inline-code-localstorage-code-api">The <code class="inline-code">localStorage</code> API</a>
            </h2><p>Once a user toggles a certain theme you need to remember what theme was chosen. Why? Well if you don’t and you reload the page or go to another page on your site then the theme will go back to the default option which may not be what the user wants.</p>
<p>How can you store the user’s chosen theme? With the <code class="inline-code">localStorage</code> API!</p>
<p>Using it is <em>Super Simple™</em>:</p>
<div class="code-block-wrapper"><div><pre class="code-block"><code class="language-js"><span class="hljs-built_in">localStorage</span>.setItem(<span class="hljs-string">&#x27;theme&#x27;</span>, theme);
<span class="hljs-built_in">localStorage</span>.getItem(<span class="hljs-string">&#x27;theme&#x27;</span>);
<span class="hljs-built_in">localStorage</span>.clear();</code></pre></div></div>
<h1 class="post-body-header">
              <a name="service-workers" href="#service-workers">Service Workers</a>
            </h1><blockquote>
<p>“Service workers essentially act as proxy servers that sit between web applications, the browser, and the network (when available).”<br><a href="https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API" title="" class="md-link">- MDN Web Docs</a></p>
</blockquote>
<p>I didn’t know what service workers were, but it turns out they can be incredibly useful, they can:</p>
<ul>
<li>Provide offline support for your site.</li>
<li>Return a cached resource but also fetch the requested resource so as to refresh the cached resource.</li>
<li>Download essential resources on startup so as to perform less requests in order to render a page at some future point in time.</li>
<li>Return custom messages in case your server cannot be reached or some other error occurred while fetching a resource.</li>
</ul>
<p>Some peculiarities regarding service workers:</p>
<ul>
<li>They only work over <code class="inline-code">https</code>.</li>
<li>They run in their own thread.</li>
<li>They follow a <code class="inline-code">Download</code>, <code class="inline-code">Install</code>, <code class="inline-code">Activate</code> lifecycle.</li>
<li>and more …</li>
</ul>
<p>You can learn more about service workers with this <a href="https://love2dev.com/blog/what-is-a-service-worker/#:~:text=Service%20workers%20are%20designed%20to,can%20intercept%20all%20network%20request.&text=Without%20a%20service%20worker%20a,you%20now%20have%20an%20application." title="" class="md-link">great introductory article</a>.</p>
<h1 class="post-body-header">
              <a name="-code-class-inline-code-async-code-and-code-class-inline-code-defer-code-attributes-for-code-class-inline-code-lt-script-gt-code-tags" href="#-code-class-inline-code-async-code-and-code-class-inline-code-defer-code-attributes-for-code-class-inline-code-lt-script-gt-code-tags"><code class="inline-code">async</code> and <code class="inline-code">defer</code> attributes for <code class="inline-code">&lt;script&gt;</code> tags</a>
            </h1><p>When including an external script in an HTML file, I always simply did this:</p>
<div class="code-block-wrapper"><div><pre class="code-block"><code class="language-js">&lt;script src=<span class="hljs-string">&quot;scripts/helloWorld.js&quot;</span>&gt;&lt;/script&gt;</code></pre></div></div>
<p>It turns out that most of the time this isn’t what you want. The way this script is included makes it a <a href="https://web.dev/render-blocking-resources/" title="" class="md-link">render-blocking resource</a>, meaning that when the HTML document is parsed and the parser gets to the script, it will stop parsing the HTML and wait for the script to download and then also wait for the script to run. All of this delays the first paint of your page (when the browser renders the first pixels to the screen).</p>
<p>Both the <code class="inline-code">async</code> and <code class="inline-code">defer</code> attributes tell the browser to not wait on the script when parsing the initial HTML document. The difference between the two is that <code class="inline-code">defer</code> specifically waits to fetch the script until the DOM is fully built, while <code class="inline-code">async</code> just fetches the script in the background and runs it whenever it’s ready.</p>
<p>I now include most of my scripts with the <code class="inline-code">async</code> attribute, I organized them as independent modules that can run whenever the browser fetches them.</p>
<p>In the case of this site, the only case where I don’t use <code class="inline-code">async</code> is the <em>critical</em> JS that I included in the HTML document itself. This JS is important enough (and small enough in size) and I need it to run ASAP, that I put it at the end of the <code class="inline-code">&lt;body&gt;</code> tag. The script in question handles toggling dark mode.</p>
<h1 class="post-body-header">
              <a name="document-state" href="#document-state">Document state</a>
            </h1><p>Something that came up when using the <code class="inline-code">async</code> tag is that I was never sure what state the DOM was in when a certain script would run. This led me to discover that the document can be in any of 3 states when it is loading:</p>
<ul>
<li><code class="inline-code">loading</code></li>
<li><code class="inline-code">interactive</code></li>
<li><code class="inline-code">complete</code></li>
</ul>
<p>You can read the state by checking <code class="inline-code">document.readyState</code>.</p>
<p>The <a href="https://developer.mozilla.org/en-US/docs/Web/API/Document/readyState" title="" class="md-link">MDN Web Docs</a> clearly explain the difference between the above three states. All I’ll say is that one state refers to when the document is being parsed, another when parsing is complete but not all sub-resources (such as images) have been loaded, and finally when the document has been parsed.</p>
<p>The key for me was figuring out if a script had a specific time I wanted it to execute and what that time corresponded to in terms of the document’s state. Usually I wanted to run a script that interacted with some elements in the DOM as soon as the DOM could be interacted with (I therefore listened for the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Document/DOMContentLoaded_event" title="" class="md-link">DOMContentLoaded</a> event).</p>
<p>A small bug I encountered was that while I had the listener, if I included the script using <code class="inline-code">async</code>, it was possible that the event in question had already been fired so the script wouldn’t do what I wanted it to. Fixing this simply involved checking the value of <code class="inline-code">document.readyState</code>.</p>
<h1 class="post-body-header">
              <a name="-code-class-inline-code-pointer-events-code-css-property" href="#-code-class-inline-code-pointer-events-code-css-property"><code class="inline-code">-pointer-events</code> CSS property</a>
            </h1><p>On the mobile version of this site, I wanted to prevent the user from clicking on anything on the page whenever the navigation menu was pulled out. At first I thought I could just put an element over the main content of the page at a higher <code class="inline-code">z-index</code> and that would prevent anything behind it from being clicked on, but I was wrong.</p>
<p>It turns out there’s a useful CSS property that can be set to achieve this.</p>
<div class="code-block-wrapper"><div><pre class="code-block"><code class="language-css"><span class="hljs-selector-class">.no-click</span> {
    <span class="hljs-attribute">pointer-events</span>: none;
}</code></pre></div></div>
<h1 class="post-body-header">
              <a name="-code-class-inline-code-min-width-code-and-code-class-inline-code-min-device-width-code-ignorance" href="#-code-class-inline-code-min-width-code-and-code-class-inline-code-min-device-width-code-ignorance"><code class="inline-code">min-width</code> and <code class="inline-code">min-device-width</code> ignorance</a>
            </h1><p>Something that was driving me wild was that I couldn’t understand why some CSS properties would take effect when the screen width changed size and why others didn’t take effect unless I was in <code class="inline-code">responsive</code> mode in Chrome’s DevTools.</p>
<p>It turns out I was using <code class="inline-code">min-width</code> and <code class="inline-code">min-device-width</code> interchangeably when I really only wanted to use <code class="inline-code">min-width</code>. I hadn’t noticed the difference between the two and this is probably due to certain “inspirations” I got looking at code on Stack Overflow (i.e. copy/pasting code).</p>
<p>As you could probably guess by their respective names <code class="inline-code">*-width</code> activates when the width of the window changes while <code class="inline-code">*-device-width</code> changes according to the width of the device’s screen.</p>
<h1 class="post-body-header">
              <a name="text-size-adjust" href="#text-size-adjust">text size adjust</a>
            </h1><p>This may seem obvious but when developing a website it’s a good idea to interact with it via different devices and see how it behaves in different circumstances. At one point I noticed that when I browsed this site on my iPhone with Safari and I switched to landscape mode, the font size would blow up.</p>
<p>As it turns out this can be fixed via a CSS property:</p>
<div class="code-block-wrapper"><div><pre class="code-block"><code class="language-css"><span class="hljs-selector-class">.disable-text-inflation</span> {
    text-size-adjust: none;
    -webkit-text-size-adjust: none;
}</code></pre></div></div>
<p>This basically tells the browser to not use any text inflation algorithm to resize the text size in certain instances (e.g. mobile Safari when switching to landscape mode).</p>
<h1 class="post-body-header">
              <a name="python-server-vs-node-server" href="#python-server-vs-node-server">python server vs node server</a>
            </h1><p>For simplicity I was using python to run a local development server:</p>
<div class="code-block-wrapper"><div><pre class="code-block"><code class="language-bash">python3 -m http.server</code></pre></div></div>
<p>However I found out I couldn’t play videos using the HTML5 video tag. I just switched to using the <a href="https://www.npmjs.com/package/http-server" title="" class="md-link">http-server</a> npm package and HTML5 videos work fine now.</p>
<h1 class="post-body-header">
              <a name="icons-using-svgs" href="#icons-using-svgs">Icons using SVGs</a>
            </h1><p>At first I was using Google’s material icons to host icons on my site. But there were a couple of problems I had with this option:</p>
<ul>
<li>Before icons loaded a user would see the “name” of the icon (e.g. <code class="inline-code">brightness_5</code>) which apart from just being ugly to see, would take up much more room than the actual icon, causing elements to shift on the page which was pretty hideous to witness.</li>
<li>Even with a fix for the above problem, there would always be a delay between the page loading and the icons showing up.
However I didn’t want to switch to using PNG images for icons because I couldn’t easily style them with CSS to match whatever theme I wanted.</li>
</ul>
<p>The solution was to use the Google material icons in SVG format. The source code for the SVGs can be found on <a href="https://github.com/google/material-design-icons/blob/master/src/image/brightness_5/materialicons/24px.svg" title="" class="md-link">GitHub</a>.</p>
<p>I just copy/pasted the SVG into the HTML document directly.</p>
<p>As far as styling the icons with CSS I found out you can use the <code class="inline-code">fill</code> property to color SVGs:</p>
<div class="code-block-wrapper"><div><pre class="code-block"><code class="language-css">svg {
    fill: black;
}

svg<span class="hljs-selector-attr">[data-theme=<span class="hljs-string">&#x27;dark&#x27;</span>]</span> {
    fill: white;
}</code></pre></div></div>
<p>Side note you can’t use the <code class="inline-code">title</code> attribute with the <code class="inline-code">&lt;svg&gt;</code> tag, but <a href="https://css-tricks.com/svg-title-vs-html-title-attribute/" title="" class="md-link">there are other ways of giving titles to SVGs</a>.</p>
<h1 class="post-body-header">
              <a name="sass-to-organize-and-minify-css" href="#sass-to-organize-and-minify-css">SASS to organize and minify CSS</a>
            </h1><p>When generating Lighthouse reports for my pages I focused on performance for a bit and ran into the conundrum of what to do with my CSS.</p>
<p>The right solution seems to be different for different situations. I read in some cases people wanted to bundle up all the CSS and put it in a <code class="inline-code">&lt;style&gt;</code> tag in the HTML document. However this would not allow for caching of different files. Bundling up all the CSS also isn’t necessarily faster than having separate files, what with parallel requests thanks to the HTTP2 protocol. Besides, in the end the same amount of CSS has to be downloaded.</p>
<p>I opted to split my CSS the following way. Have 1 file with all the CSS that is common to all pages. And another file that is page-specific. So basically each page gets 2 CSS files.</p>
<p>Obviously I didn’t want to actually have 1 giant file for all the CSS that needs to be on every page. While looking for options I stumbled upon SASS, which I had heard of, but this time I wanted to try it out specifically for its ability to combine multiple <code class="inline-code">.scss</code> files into one final <code class="inline-code">.css</code> file. It turned out to be a lovely tool, I split my CSS however was most convenient for development (e.g. having a file just for the style of the navigation bar).</p>
<p>To quickly explain what SASS does it compiles <code class="inline-code">.scss</code> files (which allow you to do cool stuff with easy syntax) into regular <code class="inline-code">.css</code> files. If you prepend your <code class="inline-code">.scss</code> filename with an underscore <code class="inline-code">_</code> that also specifies to SASS that that file is only to be imported by other <code class="inline-code">.scss</code> and not directly parsed into a <code class="inline-code">.css</code> file itself.</p>
<p>So for example you could have the following files in <code class="inline-code">/input_dir</code>:</p>
<ul>
<li><code class="inline-code">module1.scss</code></li>
<li><code class="inline-code">_module2.scss</code></li>
<li><code class="inline-code">common.scss</code></li>
</ul>
<p><code class="inline-code">common.scss</code> begins with some imports like these:</p>
<div class="code-block-wrapper"><div><pre class="code-block"><code class="language-scss"><span class="hljs-keyword">@use</span> <span class="hljs-string">&#x27;module1&#x27;</span>;
<span class="hljs-keyword">@use</span> <span class="hljs-string">&#x27;module2&#x27;</span>;</code></pre></div></div>
<p>You can generate the <code class="inline-code">.css</code> files with the following command:
(As a bonus the SASS compiler can also minify the generated CSS file.)</p>
<div class="code-block-wrapper"><div><pre class="code-block"><code class="language-bash">sass input_dir:output_dir --no-source-map --style compressed</code></pre></div></div>
<p>In <code class="inline-code">/output_dir</code> you will find two minified CSS files:</p>
<ul>
<li><code class="inline-code">module1.css</code></li>
<li><code class="inline-code">style.css</code></li>
</ul>

</div>
</div>
    <script>"use strict";!function(){var r=null;function t(){localStorage.getItem("theme")||(window.matchMedia("(prefers-color-scheme: dark)").matches?l("dark"):window.matchMedia("(prefers-color-scheme: light)").matches&&l("light"))}function n(){var e=document.getElementById("navbar");return e&&null!==(e=e.dataset.theme)&&void 0!==e?e:null}function a(){var e=localStorage.getItem("theme");e&&e!==n()&&l(e)}function l(e){if(r){for(var t=0;t<r.length;t++){var n=r[t];(n instanceof HTMLElement||n instanceof SVGElement)&&(n.dataset.theme=e)}var a=document.getElementById("theme-link"),l=(null===(l=null==a?void 0:a.getAttribute("href"))||void 0===l?void 0:l.split("style/")[0])+"style/";"light"===e?a&&a.setAttribute("href",l+"github.css"):a&&a.setAttribute("href",l+"tomorrow-night-bright.css"),a=e,(l=document.getElementById("switch-theme-btn"))&&l instanceof HTMLInputElement&&(l.checked="dark"===a)}}!function(){r=document.querySelectorAll(" [data-themeable] "),t(),a(),function(){try{window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change",function(e){t()})}catch(e){try{window.matchMedia("(prefers-color-scheme: dark)").addListener(function(e){t()})}catch(e){console.error(e)}}}();var e=document.getElementById("switch-theme-btn");null!=e&&e.addEventListener("click",function(){var e,t=null;localStorage.getItem("theme")&&"dark"===localStorage.getItem("theme")?t="light":localStorage.getItem("theme")&&"light"===localStorage.getItem("theme")?t="dark":localStorage.getItem("theme")||(t=(e=n())&&"dark"==e?"light":"dark"),t=null!=t?t:"light",localStorage.setItem("theme",t),a()})}(),setInterval(function(){a()},2e3)}()</script>

  </body>
</html>
