<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/6c97bd85c45b5edf.css" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/fadc07fb3bbae6bd.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-d1479157349f8417.js"/><script src="/_next/static/chunks/4bd1b696-3f96248ea2fc019a.js" async=""></script><script src="/_next/static/chunks/517-1c1418b725535656.js" async=""></script><script src="/_next/static/chunks/main-app-edf91be93d3a5361.js" async=""></script><script src="/_next/static/chunks/173-a3c63069a57a6ffb.js" async=""></script><script src="/_next/static/chunks/app/blog/validating-your-environment-variables-at-build-time/page-d21f719e547cf8e9.js" async=""></script><script src="/_next/static/chunks/app/layout-92cb53813bf43f18.js" async=""></script><meta name="next-size-adjust" content=""/><meta name="author" content="Alessio Palladino"/><meta id="meta-theme-color" name="theme-color"/><title>Validating Your Environment Variables at Build Time • Alessio Palladino</title><meta name="description" content="Why and how to validate your environment variables in Next.js at build time"/><link rel="icon" href="/favicon.ico" type="image/x-icon" sizes="32x32"/><link id="dark-css" rel="stylesheet" href="/dark.css"/><link id="light-css" rel="stylesheet" href="/light.css"/><script src="/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body class="__className_e8ce0c"><script src="/theme.js"></script><div class="flex justify-center px-4"><div class="flex flex-col min-h-dvh max-w-screen-lg w-full"><div class="navbar"><div class="flex-1"><a class="btn btn-ghost no-animation text-xl" href="/">Home</a></div><div class="flex-none pr-2"><a class="btn btn-ghost no-animation text-xl" href="/about">About</a><a class="btn btn-ghost no-animation text-xl" href="/blog">Blog</a></div><button class="dark-mode-btn btn-ghost"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-moon moon-icon"><path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"></path></svg></button></div><div><div class="flex justify-center py-8"><div class="max-w-screen-md w-full"><div class="pb-4"><a class="flex items-center justify-center size-[48px] rounded-full btn-ghost" href="/blog"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-arrow-left"><path d="m12 19-7-7 7-7"></path><path d="M19 12H5"></path></svg></a></div><article class="prose prose-lg"><h1>Validating Your Environment Variables at Build Time</h1>
<div><small><i>Published<!-- --> <!-- -->December 7th, 2024</i></small></div>
<div><small><i>Updated<!-- --> <!-- -->March 2nd, 2025</i></small></div>
<p>Today I&#x27;d like to share a simple idea with you in a short and sweet article.
Not so long ago, at work, we suffered an unexpected bug when an environment variable was missing from one of our web apps.
To prevent similar bugs in the future, we decided to validate our environment variables at build time.
In the next few paragraphs I&#x27;ll go over how we did that and discuss alternative implementations.</p>
<h2 id="the-value-of-validating-your-environment-variables-at-build-time" class="styles_linktitle__p04j4"><a href="#the-value-of-validating-your-environment-variables-at-build-time" class="no-underline">The Value of Validating Your Environment Variables at Build Time</a></h2>
<p>It must be said that the kinds of bugs I mentioned above are rare. But, when they happen in production… they can be catastrophic.
Of course these cases are unlikely to happen thanks to version control systems and code reviews, but unlikely does not mean impossible.</p>
<p>There&#x27;s also a lot of value in doing this for your development environment.
It has often happened that I and other engineers I work with end up wasting time investigating why an app isn&#x27;t behaving properly in our local environment.
Only to find out we had a misconfigured <code>.env</code> file. Sometimes the <code>.env</code> file was missing altogether.</p>
<p>This may happen more often in my case, at work.
The reason being that we host multiple apps in a monorepo and use <a href="https://nx.dev/">Nx</a> to swiftly generate new apps.
We commit a distribution version of our <code>.env</code> file (<code>.env.dist</code>) for every app.
Therefore, when moving from app to app you can see how there may be issues with misconfigured or missing <code>.env</code> files, which are untracked by Git, not matching the <code>.env.dist</code> examples.</p>
<h2 id="technical-implementation" class="styles_linktitle__p04j4"><a href="#technical-implementation" class="no-underline">Technical Implementation</a></h2>
<p>Now on to how to actually do this in Next.js. Really it&#x27;s just two steps:</p>
<ol>
<li>Define a schema</li>
<li>Validate <code>process.env</code> in your <code>next.config.ts</code></li>
</ol>
<h3 id="define-a-schema" class="styles_linktitle__p04j4"><a href="#define-a-schema" class="no-underline">Define a Schema</a></h3>
<p><a href="https://zod.dev/">Zod</a>
is a great tool to handle this, though at work we use <a href="https://gcanti.github.io/io-ts/">io-ts</a>.
Both are similar. However, in this post I&#x27;ll use Zod since it&#x27;s more widely used.</p>
<p>Now, you&#x27;ll likely want to establish a convention for the name and location of your schema.
For example we created a file called <code>dotEnv.ts</code> in the root of each of our application projects.</p>
<p>In our case let&#x27;s call this file <code>envSchema.ts</code> and place it in the root of our project:</p>
<pre class="break-words code-block text-wrap"><code class="language-ts hljs"><span class="hljs-keyword">import</span> { z } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;zod&quot;</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> envSchema = z.<span class="hljs-title function_">object</span>({
  <span class="hljs-attr">ENVIRONMENT</span>: z.<span class="hljs-title function_">union</span>([z.<span class="hljs-title function_">literal</span>(<span class="hljs-string">&quot;development&quot;</span>), z.<span class="hljs-title function_">literal</span>(<span class="hljs-string">&quot;production&quot;</span>)]),
})
</code></pre>
<p>Define whatever schema you need depending on the variables in your <code>.env</code> file.</p>
<h3 id="parse-processenv" class="styles_linktitle__p04j4"><a href="#parse-processenv" class="no-underline">Parse <code>process.env</code></a></h3>
<p>Then in your <code>next.config.ts</code>, you can simply validate <code>process.env</code> against the schema:</p>
<pre class="break-words code-block text-wrap"><code class="language-ts hljs"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">NextConfig</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;next&quot;</span>
<span class="hljs-keyword">import</span> { envSchema } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./envSchema&quot;</span>

envSchema.<span class="hljs-title function_">parse</span>(process.<span class="hljs-property">env</span>)

<span class="hljs-keyword">const</span> <span class="hljs-attr">nextConfig</span>: <span class="hljs-title class_">NextConfig</span> = {
</code></pre>
<p>The difference with other articles I&#x27;ve seen regarding this topic is the location where we&#x27;re doing the validation.
Here we&#x27;re in the <code>next.config.ts</code> file, and in case the validation fails, <code>parse()</code> throws an error.
Effectively breaking the build process, which will also break any CD pipeline. It&#x27;s weird to say but that&#x27;s what we want.
I&#x27;d rather a functioning version of the app stay in production, instead of a buggy one due to misconfigured environment variables.
Besides, the error that is thrown is easy to recognize and easier to fix.</p>
<p>One thing to know is that the <code>next.config.ts</code> configuration is loaded multiple times, sometimes by different processes.
Therefore adding lots of extra complexity may slow things down.
In our case the complexity we introduced is minimal, especially considering the benefits we get in return.</p>
<p>Something you may want to do is limit this logic to a specific context in which the configuration is being loaded.
For that you can specify a
<a href="https://nextjs.org/docs/pages/api-reference/next-config-js#phase">phase</a>
in which to validate the environment.</p>
<h2 id="extra-features" class="styles_linktitle__p04j4"><a href="#extra-features" class="no-underline">Extra Features</a></h2>
<p>You can stop here, the implementation doesn&#x27;t need to get more complicated and you don&#x27;t need to introduce other
tools or libraries to do more. In this case only a few lines of extra code add a world of benefit as far as the robustness
of our app is concerned. In fact, we haven&#x27;t gone any further with this at work (yet). But, in the spirit of exploring additional benefits,
I&#x27;d like to address a few extra points.</p>
<h3 id="exporting-the-parsed-environment-variables" class="styles_linktitle__p04j4"><a href="#exporting-the-parsed-environment-variables" class="no-underline">Exporting the Parsed Environment Variables</a></h3>
<p>Once you&#x27;ve validated <code>process.env</code> you can store the result and export it. Using that throughout your app instead of calling <code>process.env</code>.</p>
<p>Personally I think this sounds good, but in practice I don&#x27;t like that there&#x27;s nothing preventing developers from accessing <code>process.env</code>.
Having two sources of truth hurts readability and adds unnecessary complexity.
The same could be said for exporting the <em>type</em> of the environment variables.</p>
<h3 id="extending-the-global-processenv" class="styles_linktitle__p04j4"><a href="#extending-the-global-processenv" class="no-underline">Extending the global <code>ProcessEnv</code></a></h3>
<p>Instead of directly exporting the <em>type</em> of the environment variables,
you can extend the global <code>ProcessEnv</code> type by telling zod to infer the types derivable from the schema we defined earlier.</p>
<p>This is cute since you can get nice autocomplete suggestions in your editor when accessing <code>process.env</code>.
However, no matter the inferred types, the actual value will always be a string, that&#x27;s just how <code>process.env</code> works.
For that reason, I would avoid this extra implementation.</p>
<pre class="break-words code-block text-wrap"><code class="language-ts hljs"><span class="hljs-keyword">declare</span> <span class="hljs-variable language_">global</span> {
  <span class="hljs-keyword">namespace</span> <span class="hljs-title class_">NodeJS</span> {
    <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ProcessEnv</span> <span class="hljs-keyword">extends</span> z.infer&lt;typeof envSchema&gt; {}
  }
}
</code></pre>
<h3 id="using-an-external-library" class="styles_linktitle__p04j4"><a href="#using-an-external-library" class="no-underline">Using an External Library</a></h3>
<p><a href="https://env.t3.gg/">Create T3 App</a> has an interesting approach to this problem, creating a
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy">Proxy</a>
for <code>process.env</code> to get the nice features I mentioned above, and more.
In my opinion if you need that extra strictness and robustness for your application, this library could be for you.</p>
<p>However, in most cases a simple approach as mentioned in the beginning of this post can be enough to prevent the worst bugs.
Additionally, Next.js handles <code>.env</code> files out of the box and provides useful conventions such as splitting client and server environment variables simply by
prefixing the variables with <code>NEXT_PUBLIC_</code>.
By adopting the T3 tool you lose these goodies and must instead adopt the library&#x27;s conventions (such as splitting your schemas between client and server).
So keep that in mind.</p>
<h2 id="conclusion" class="styles_linktitle__p04j4"><a href="#conclusion" class="no-underline">Conclusion</a></h2>
<p>Validating your environment variables at build time can be incredibly useful.
With just a few lines of code you get an easy win.
Beyond that, you&#x27;re free to choose how much more you want to implement yourself before deciding to adopt an external tool.</p>
<p>Update: Since this article was published, at work we&#x27;ve extended our environment variable validation to our React Native applications.
Therefore an additional advantage to owning your own simple implementation is that you can also handle this validation for React Native.
The only difference being that instead of validating your schema in the <code>next.config.ts</code>, you need to do it in your
<code>metro.config.js</code>. Of course the other difference is that you&#x27;ll need to convert the code to JavaScript, so there will be small syntax differences.</p></article></div></div></div></div></div><script src="/_next/static/chunks/webpack-d1479157349f8417.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[8173,[\"173\",\"static/chunks/173-a3c63069a57a6ffb.js\",\"296\",\"static/chunks/app/blog/validating-your-environment-variables-at-build-time/page-d21f719e547cf8e9.js\"],\"\"]\n3:I[3143,[\"173\",\"static/chunks/173-a3c63069a57a6ffb.js\",\"177\",\"static/chunks/app/layout-92cb53813bf43f18.js\"],\"ThemeSwitcher\"]\n4:I[5244,[],\"\"]\n5:I[3866,[],\"\"]\n6:I[6213,[],\"OutletBoundary\"]\n8:I[6213,[],\"MetadataBoundary\"]\na:I[6213,[],\"ViewportBoundary\"]\nc:I[4835,[],\"\"]\n:HL[\"/_next/static/media/e4af272ccee01ff0-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/css/6c97bd85c45b5edf.css\",\"style\"]\n:HL[\"/_next/static/css/fadc07fb3bbae6bd.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"DsFlROoSK6_ngOou2kX-9\",\"p\":\"\",\"c\":[\"\",\"blog\",\"validating-your-environment-variables-at-build-time\"],\"i\":false,\"f\":[[[\"\",{\"children\":[\"blog\",{\"children\":[\"validating-your-environment-variables-at-build-time\",{\"children\":[\"__PAGE__\",{}]}]}]},\"$undefined\",\"$undefined\",true],[\"\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/6c97bd85c45b5edf.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"en\",\"data-theme\":\"light\",\"suppressHydrationWarning\":true,\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"meta\",null,{\"name\":\"author\",\"content\":\"Alessio Palladino\"}],[\"$\",\"meta\",null,{\"id\":\"meta-theme-color\",\"name\":\"theme-color\"}],[\"$\",\"link\",null,{\"id\":\"dark-css\",\"rel\":\"stylesheet\",\"href\":\"/dark.css\",\"suppressHydrationWarning\":true}],[\"$\",\"link\",null,{\"id\":\"light-css\",\"rel\":\"stylesheet\",\"href\":\"/light.css\",\"suppressHydrationWarning\":true}]]}],[\"$\",\"body\",null,{\"className\":\"__className_e8ce0c\",\"children\":[[\"$\",\"script\",null,{\"src\":\"/theme.js\"}],[\"$\",\"div\",null,{\"className\":\"flex justify-center px-4\",\"children\":[\"$\",\"div\",null,{\"className\":\"flex flex-col min-h-dvh max-w-screen-lg w-full\",\"children\":[[\"$\",\"div\",null,{\"className\":\"navbar\",\"children\":[[\"$\",\"div\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"$L2\",null,{\"className\":\"btn btn-ghost no-animation text-xl\",\"href\":\"/\",\"children\":\"Home\"}]}],[\"$\",\"div\",null,{\"className\":\"flex-none pr-2\",\"children\":[[\"$\",\"$L2\",null,{\"className\":\"btn btn-ghost no-animation text-xl\",\"href\":\"/about\",\"children\":\"About\"}],[\"$\",\"$L2\",null,{\"className\":\"btn btn-ghost no-animation text-xl\",\"href\":\"/blog\",\"children\":\"Blog\"}]]}],[\"$\",\"$L3\",null,{}]]}],[\"$\",\"$L4\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L5\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[],[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":404}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}]}]]}]]}]]}],{\"children\":[\"blog\",[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L4\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"blog\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L5\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[\"validating-your-environment-variables-at-build-time\",[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L4\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"blog\",\"children\",\"validating-your-environment-variables-at-build-time\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L5\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[\"__PAGE__\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"div\",\"validating-your-environment-variables-at-build-time\",{\"children\":[[\"$\",\"title\",null,{\"children\":\"Validating Your Environment Variables at Build Time • Alessio Palladino\"}],[\"$\",\"meta\",null,{\"name\":\"description\",\"content\":\"Why and how to validate your environment variables in Next.js at build time\"}],[\"$\",\"div\",null,{\"className\":\"flex justify-center py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-screen-md w-full\",\"children\":[[\"$\",\"div\",null,{\"className\":\"pb-4\",\"children\":[\"$\",\"$L2\",null,{\"className\":\"flex items-center justify-center size-[48px] rounded-full btn-ghost\",\"href\":\"/blog\",\"children\":[\"$\",\"svg\",null,{\"ref\":\"$undefined\",\"xmlns\":\"http://www.w3.org/2000/svg\",\"width\":32,\"height\":32,\"viewBox\":\"0 0 24 24\",\"fill\":\"none\",\"stroke\":\"currentColor\",\"strokeWidth\":2,\"strokeLinecap\":\"round\",\"strokeLinejoin\":\"round\",\"className\":\"lucide lucide-arrow-left\",\"children\":[[\"$\",\"path\",\"1l729n\",{\"d\":\"m12 19-7-7 7-7\"}],[\"$\",\"path\",\"x3x0zl\",{\"d\":\"M19 12H5\"}],\"$undefined\"]}]}]}],[\"$\",\"article\",null,{\"className\":\"prose prose-lg\",\"children\":[[\"$\",\"h1\",null,{\"children\":\"Validating Your Environment Variables at Build Time\"}],\"\\n\",[\"$\",\"div\",null,{\"children\":[\"$\",\"small\",null,{\"children\":[\"$\",\"i\",null,{\"children\":[\"Published\",\" \",\"December 7th, 2024\"]}]}]}],\"\\n\",[\"$\",\"div\",null,{\"children\":[\"$\",\"small\",null,{\"children\":[\"$\",\"i\",null,{\"children\":[\"Updated\",\" \",\"March 2nd, 2025\"]}]}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"Today I'd like to share a simple idea with you in a short and sweet article.\\nNot so long ago, at work, we suffered an unexpected bug when an environment variable was missing from one of our web apps.\\nTo prevent similar bugs in the future, we decided to validate our environment variables at build time.\\nIn the next few paragraphs I'll go over how we did that and discuss alternative implementations.\"}],\"\\n\",[\"$\",\"h2\",null,{\"id\":\"the-value-of-validating-your-environment-variables-at-build-time\",\"className\":\"styles_linktitle__p04j4\",\"children\":[\"$\",\"a\",null,{\"href\":\"#the-value-of-validating-your-environment-variables-at-build-time\",\"className\":\"no-underline\",\"children\":\"The Value of Validating Your Environment Variables at Build Time\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"It must be said that the kinds of bugs I mentioned above are rare. But, when they happen in production… they can be catastrophic.\\nOf course these cases are unlikely to happen thanks to version control systems and code reviews, but unlikely does not mean impossible.\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"There's also a lot of value in doing this for your development environment.\\nIt has often happened that I and other engineers I work with end up wasting time investigating why an app isn't behaving properly in our local environment.\\nOnly to find out we had a misconfigured \",[\"$\",\"code\",null,{\"children\":\".env\"}],\" file. Sometimes the \",[\"$\",\"code\",null,{\"children\":\".env\"}],\" file was missing altogether.\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"This may happen more often in my case, at work.\\nThe reason being that we host multiple apps in a monorepo and use \",[\"$\",\"a\",null,{\"href\":\"https://nx.dev/\",\"children\":\"Nx\"}],\" to swiftly generate new apps.\\nWe commit a distribution version of our \",[\"$\",\"code\",null,{\"children\":\".env\"}],\" file (\",[\"$\",\"code\",null,{\"children\":\".env.dist\"}],\") for every app.\\nTherefore, when moving from app to app you can see how there may be issues with misconfigured or missing \",[\"$\",\"code\",null,{\"children\":\".env\"}],\" files, which are untracked by Git, not matching the \",[\"$\",\"code\",null,{\"children\":\".env.dist\"}],\" examples.\"]}],\"\\n\",[\"$\",\"h2\",null,{\"id\":\"technical-implementation\",\"className\":\"styles_linktitle__p04j4\",\"children\":[\"$\",\"a\",null,{\"href\":\"#technical-implementation\",\"className\":\"no-underline\",\"children\":\"Technical Implementation\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"Now on to how to actually do this in Next.js. Really it's just two steps:\"}],\"\\n\",[\"$\",\"ol\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"Define a schema\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"Validate \",[\"$\",\"code\",null,{\"children\":\"process.env\"}],\" in your \",[\"$\",\"code\",null,{\"children\":\"next.config.ts\"}]]}],\"\\n\"]}],\"\\n\",[\"$\",\"h3\",null,{\"id\":\"define-a-schema\",\"className\":\"styles_linktitle__p04j4\",\"children\":[\"$\",\"a\",null,{\"href\":\"#define-a-schema\",\"className\":\"no-underline\",\"children\":\"Define a Schema\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[[\"$\",\"a\",null,{\"href\":\"https://zod.dev/\",\"children\":\"Zod\"}],\"\\nis a great tool to handle this, though at work we use \",[\"$\",\"a\",null,{\"href\":\"https://gcanti.github.io/io-ts/\",\"children\":\"io-ts\"}],\".\\nBoth are similar. However, in this post I'll use Zod since it's more widely used.\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"Now, you'll likely want to establish a convention for the name and location of your schema.\\nFor example we created a file called \",[\"$\",\"code\",null,{\"children\":\"dotEnv.ts\"}],\" in the root of each of our application projects.\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"In our case let's call this file \",[\"$\",\"code\",null,{\"children\":\"envSchema.ts\"}],\" and place it in the root of our project:\"]}],\"\\n\",[\"$\",\"pre\",null,{\"className\":\"break-words code-block text-wrap\",\"children\":[\"$\",\"code\",null,{\"className\":\"language-ts hljs\",\"dangerouslySetInnerHTML\":{\"__html\":\"\u003cspan class=\\\"hljs-keyword\\\"\u003eimport\u003c/span\u003e { z } \u003cspan class=\\\"hljs-keyword\\\"\u003efrom\u003c/span\u003e \u003cspan class=\\\"hljs-string\\\"\u003e\u0026quot;zod\u0026quot;\u003c/span\u003e\\n\\n\u003cspan class=\\\"hljs-keyword\\\"\u003eexport\u003c/span\u003e \u003cspan class=\\\"hljs-keyword\\\"\u003econst\u003c/span\u003e envSchema = z.\u003cspan class=\\\"hljs-title function_\\\"\u003eobject\u003c/span\u003e({\\n  \u003cspan class=\\\"hljs-attr\\\"\u003eENVIRONMENT\u003c/span\u003e: z.\u003cspan class=\\\"hljs-title function_\\\"\u003eunion\u003c/span\u003e([z.\u003cspan class=\\\"hljs-title function_\\\"\u003eliteral\u003c/span\u003e(\u003cspan class=\\\"hljs-string\\\"\u003e\u0026quot;development\u0026quot;\u003c/span\u003e), z.\u003cspan class=\\\"hljs-title function_\\\"\u003eliteral\u003c/span\u003e(\u003cspan class=\\\"hljs-string\\\"\u003e\u0026quot;production\u0026quot;\u003c/span\u003e)]),\\n})\\n\"}}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"Define whatever schema you need depending on the variables in your \",[\"$\",\"code\",null,{\"children\":\".env\"}],\" file.\"]}],\"\\n\",[\"$\",\"h3\",null,{\"id\":\"parse-processenv\",\"className\":\"styles_linktitle__p04j4\",\"children\":[\"$\",\"a\",null,{\"href\":\"#parse-processenv\",\"className\":\"no-underline\",\"children\":[\"Parse \",[\"$\",\"code\",null,{\"children\":\"process.env\"}]]}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"Then in your \",[\"$\",\"code\",null,{\"children\":\"next.config.ts\"}],\", you can simply validate \",[\"$\",\"code\",null,{\"children\":\"process.env\"}],\" against the schema:\"]}],\"\\n\",[\"$\",\"pre\",null,{\"className\":\"break-words code-block text-wrap\",\"children\":[\"$\",\"code\",null,{\"className\":\"language-ts hljs\",\"dangerouslySetInnerHTML\":{\"__html\":\"\u003cspan class=\\\"hljs-keyword\\\"\u003eimport\u003c/span\u003e { \u003cspan class=\\\"hljs-title class_\\\"\u003eNextConfig\u003c/span\u003e } \u003cspan class=\\\"hljs-keyword\\\"\u003efrom\u003c/span\u003e \u003cspan class=\\\"hljs-string\\\"\u003e\u0026quot;next\u0026quot;\u003c/span\u003e\\n\u003cspan class=\\\"hljs-keyword\\\"\u003eimport\u003c/span\u003e { envSchema } \u003cspan class=\\\"hljs-keyword\\\"\u003efrom\u003c/span\u003e \u003cspan class=\\\"hljs-string\\\"\u003e\u0026quot;./envSchema\u0026quot;\u003c/span\u003e\\n\\nenvSchema.\u003cspan class=\\\"hljs-title function_\\\"\u003eparse\u003c/span\u003e(process.\u003cspan class=\\\"hljs-property\\\"\u003eenv\u003c/span\u003e)\\n\\n\u003cspan class=\\\"hljs-keyword\\\"\u003econst\u003c/span\u003e \u003cspan class=\\\"hljs-attr\\\"\u003enextConfig\u003c/span\u003e: \u003cspan class=\\\"hljs-title class_\\\"\u003eNextConfig\u003c/span\u003e = {\\n\"}}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"The difference with other articles I've seen regarding this topic is the location where we're doing the validation.\\nHere we're in the \",[\"$\",\"code\",null,{\"children\":\"next.config.ts\"}],\" file, and in case the validation fails, \",[\"$\",\"code\",null,{\"children\":\"parse()\"}],\" throws an error.\\nEffectively breaking the build process, which will also break any CD pipeline. It's weird to say but that's what we want.\\nI'd rather a functioning version of the app stay in production, instead of a buggy one due to misconfigured environment variables.\\nBesides, the error that is thrown is easy to recognize and easier to fix.\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"One thing to know is that the \",[\"$\",\"code\",null,{\"children\":\"next.config.ts\"}],\" configuration is loaded multiple times, sometimes by different processes.\\nTherefore adding lots of extra complexity may slow things down.\\nIn our case the complexity we introduced is minimal, especially considering the benefits we get in return.\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"Something you may want to do is limit this logic to a specific context in which the configuration is being loaded.\\nFor that you can specify a\\n\",[\"$\",\"a\",null,{\"href\":\"https://nextjs.org/docs/pages/api-reference/next-config-js#phase\",\"children\":\"phase\"}],\"\\nin which to validate the environment.\"]}],\"\\n\",[\"$\",\"h2\",null,{\"id\":\"extra-features\",\"className\":\"styles_linktitle__p04j4\",\"children\":[\"$\",\"a\",null,{\"href\":\"#extra-features\",\"className\":\"no-underline\",\"children\":\"Extra Features\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"You can stop here, the implementation doesn't need to get more complicated and you don't need to introduce other\\ntools or libraries to do more. In this case only a few lines of extra code add a world of benefit as far as the robustness\\nof our app is concerned. In fact, we haven't gone any further with this at work (yet). But, in the spirit of exploring additional benefits,\\nI'd like to address a few extra points.\"}],\"\\n\",[\"$\",\"h3\",null,{\"id\":\"exporting-the-parsed-environment-variables\",\"className\":\"styles_linktitle__p04j4\",\"children\":[\"$\",\"a\",null,{\"href\":\"#exporting-the-parsed-environment-variables\",\"className\":\"no-underline\",\"children\":\"Exporting the Parsed Environment Variables\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"Once you've validated \",[\"$\",\"code\",null,{\"children\":\"process.env\"}],\" you can store the result and export it. Using that throughout your app instead of calling \",[\"$\",\"code\",null,{\"children\":\"process.env\"}],\".\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"Personally I think this sounds good, but in practice I don't like that there's nothing preventing developers from accessing \",[\"$\",\"code\",null,{\"children\":\"process.env\"}],\".\\nHaving two sources of truth hurts readability and adds unnecessary complexity.\\nThe same could be said for exporting the \",[\"$\",\"em\",null,{\"children\":\"type\"}],\" of the environment variables.\"]}],\"\\n\",[\"$\",\"h3\",null,{\"id\":\"extending-the-global-processenv\",\"className\":\"styles_linktitle__p04j4\",\"children\":[\"$\",\"a\",null,{\"href\":\"#extending-the-global-processenv\",\"className\":\"no-underline\",\"children\":[\"Extending the global \",[\"$\",\"code\",null,{\"children\":\"ProcessEnv\"}]]}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"Instead of directly exporting the \",[\"$\",\"em\",null,{\"children\":\"type\"}],\" of the environment variables,\\nyou can extend the global \",[\"$\",\"code\",null,{\"children\":\"ProcessEnv\"}],\" type by telling zod to infer the types derivable from the schema we defined earlier.\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"This is cute since you can get nice autocomplete suggestions in your editor when accessing \",[\"$\",\"code\",null,{\"children\":\"process.env\"}],\".\\nHowever, no matter the inferred types, the actual value will always be a string, that's just how \",[\"$\",\"code\",null,{\"children\":\"process.env\"}],\" works.\\nFor that reason, I would avoid this extra implementation.\"]}],\"\\n\",[\"$\",\"pre\",null,{\"className\":\"break-words code-block text-wrap\",\"children\":[\"$\",\"code\",null,{\"className\":\"language-ts hljs\",\"dangerouslySetInnerHTML\":{\"__html\":\"\u003cspan class=\\\"hljs-keyword\\\"\u003edeclare\u003c/span\u003e \u003cspan class=\\\"hljs-variable language_\\\"\u003eglobal\u003c/span\u003e {\\n  \u003cspan class=\\\"hljs-keyword\\\"\u003enamespace\u003c/span\u003e \u003cspan class=\\\"hljs-title class_\\\"\u003eNodeJS\u003c/span\u003e {\\n    \u003cspan class=\\\"hljs-keyword\\\"\u003einterface\u003c/span\u003e \u003cspan class=\\\"hljs-title class_\\\"\u003eProcessEnv\u003c/span\u003e \u003cspan class=\\\"hljs-keyword\\\"\u003eextends\u003c/span\u003e z.infer\u0026lt;typeof envSchema\u0026gt; {}\\n  }\\n}\\n\"}}]}],\"\\n\",[\"$\",\"h3\",null,{\"id\":\"using-an-external-library\",\"className\":\"styles_linktitle__p04j4\",\"children\":[\"$\",\"a\",null,{\"href\":\"#using-an-external-library\",\"className\":\"no-underline\",\"children\":\"Using an External Library\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[[\"$\",\"a\",null,{\"href\":\"https://env.t3.gg/\",\"children\":\"Create T3 App\"}],\" has an interesting approach to this problem, creating a\\n\",[\"$\",\"a\",null,{\"href\":\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy\",\"children\":\"Proxy\"}],\"\\nfor \",[\"$\",\"code\",null,{\"children\":\"process.env\"}],\" to get the nice features I mentioned above, and more.\\nIn my opinion if you need that extra strictness and robustness for your application, this library could be for you.\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"However, in most cases a simple approach as mentioned in the beginning of this post can be enough to prevent the worst bugs.\\nAdditionally, Next.js handles \",[\"$\",\"code\",null,{\"children\":\".env\"}],\" files out of the box and provides useful conventions such as splitting client and server environment variables simply by\\nprefixing the variables with \",[\"$\",\"code\",null,{\"children\":\"NEXT_PUBLIC_\"}],\".\\nBy adopting the T3 tool you lose these goodies and must instead adopt the library's conventions (such as splitting your schemas between client and server).\\nSo keep that in mind.\"]}],\"\\n\",[\"$\",\"h2\",null,{\"id\":\"conclusion\",\"className\":\"styles_linktitle__p04j4\",\"children\":[\"$\",\"a\",null,{\"href\":\"#conclusion\",\"className\":\"no-underline\",\"children\":\"Conclusion\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"Validating your environment variables at build time can be incredibly useful.\\nWith just a few lines of code you get an easy win.\\nBeyond that, you're free to choose how much more you want to implement yourself before deciding to adopt an external tool.\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"Update: Since this article was published, at work we've extended our environment variable validation to our React Native applications.\\nTherefore an additional advantage to owning your own simple implementation is that you can also handle this validation for React Native.\\nThe only difference being that instead of validating your schema in the \",[\"$\",\"code\",null,{\"children\":\"next.config.ts\"}],\", you need to do it in your\\n\",[\"$\",\"code\",null,{\"children\":\"metro.config.js\"}],\". Of course the other difference is that you'll need to convert the code to JavaScript, so there will be small syntax differences.\"]}]]}]]}]}]]}]],[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/fadc07fb3bbae6bd.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"$L6\",null,{\"children\":\"$L7\"}]]}],{},null,false]},null,false]},null,false]},null,false],[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$1\",\"f6mVLO33Aq77_u67jmZPb\",{\"children\":[[\"$\",\"$L8\",null,{\"children\":\"$L9\"}],[\"$\",\"$La\",null,{\"children\":\"$Lb\"}],[\"$\",\"meta\",null,{\"name\":\"next-size-adjust\",\"content\":\"\"}]]}]]}],false]],\"m\":\"$undefined\",\"G\":[\"$c\",\"$undefined\"],\"s\":false,\"S\":true}\n"])</script><script>self.__next_f.push([1,"b:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\n9:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"link\",\"1\",{\"rel\":\"icon\",\"href\":\"/favicon.ico\",\"type\":\"image/x-icon\",\"sizes\":\"32x32\"}]]\n"])</script><script>self.__next_f.push([1,"7:null\n"])</script></body></html>